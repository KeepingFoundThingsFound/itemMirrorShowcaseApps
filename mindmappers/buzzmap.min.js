// +---------------------------------------------------------------------+ \\
// | Buzzmap 2.0.3 - mindmaps with ease                                  | \\
// +---------------------------------------------------------------------| \\
// | Copyright (c) 2011-2012 Marcel Klehr                                | \\
// | Copyright (c) 2008-2010 Kenneth Kufluk (http://kenneth.kufluk.com)  | \\
// | Copyright (c) 2011      Jerome Etienne (http://jetienne.com)        | \\
// | Licensed under the MIT (X11) license.                               | \\
// +---------------------------------------------------------------------+ \\

(function (c) {
    function k(a, b, d)
    { this.obj = a; this.start = b; this.end = d }
    var j = function () { };
    j.prototype =
        {
            bind: function (a, b) { this._events = this._events || {}; this._events[a] = this._events[a] || []; this._events[a].push(b) },
            unbind: function (a, b)
            { this._events = this._events || {}; a in this._events !== !1 && this._events[a].splice(this._events[a].indexOf(b), 1) },
            trigger: function (a) {
                this._events = this._events || {};
                if (a in this._events !== !1) for (var b = 0; b < this._events[a].length; b++) this._events[a][b].apply(this, Array.prototype.slice.call(arguments, 1))
            }
        };
    j.mixin = function (a)
    {
        for (var b = ["bind", "unbind", "trigger"], d = 0; d < b.length; d++)
            a.prototype[b[d]] = j.prototype[b[d]]
    };
    k.prototype.updatePosition = function ()
    {
        if (this.start.visible && this.end.visible)
            this.strokeStyle = this.obj.options.lineColor,
            this.strokeWidth = this.obj.options.lineWidth,
            this.strokeOpacity = this.obj.options.lineOpacity,
            this.obj.canvas.path("M" + this.start.x + " " + this.start.y + "L" + this.end.x + " " + this.end.y).attr({ stroke: this.strokeStyle, opacity: this.strokeOpacity, "stroke-width": this.strokeWidth })
    };
    var h = function (a, b, d) {
        var g = this; this.obj = a; this.parent = b; this.children = [];
        this.y = this.x = 1; this.dy = this.dx = 0; this.hasPosition = this.dragging = this.editing = this.visible = !1;
        this.el = c("<div></div>"); this.el.css("position", "absolute");
        this.el.addClass("node");
        this.obj.el.append(this.el);
        this.el.hide();
        this.label(d);
        this.parent ? (this.parent.children.push(this), this.parent.parent ? this.obj.lines[this.obj.lines.length] = new k(a, this, b) : (this.el.addClass("active"), this.el.addClass("root"))) : this.el.addClass("active");
        this.el.mouseup(function () {
            if (g.dragging == !0 || g.editing == !0) return !0;
            if (g.obj.options.editable !== !0) return g.toggleChildren(), !0; window.setTimeout(function () { if (g.editing == !0) return !0; g.toggleChildren() }, 250); return !0
        });
        this.el.draggable({
            cancel: ":input,option,button,a", start: function () { g.dragging = !0 }, drag: function () { g.obj.trigger("ondrag", g); g.obj.animate() },
            stop: function () { g.dragging = !1 }
        });
        this.obj.options.editable === !0 && this.el.dblclick(function (a) { g.edit(); a.preventDefault() }) // tried to change
        /*this.el.hover(function (a){tooltip.pop(this, 'Double click on node to edit this node')})*/ // amit changed*/
    };
    h.prototype.toggleChildren = function () {
        return this.children.length > 0 && this.parent.parent ? (this.el.toggleClass("active"), this.obj.animate(), !1) : !0
    };
    h.prototype.label = function (a) {
        typeof a !== "undefined" && this.el.html(c(a)); return c(":eq(0)", this.el).html()
    };
    h.prototype.serialize = function () {
        return JSON.stringify(this.toJSON())
    };
    h.prototype.toJSON = function () {
        var a = { label: c(this.el).html(), children: [] };
        c.each(this.children, function () { a.children.push(this.toJSON()) }); return a
    };
    h.prototype.edit = function () {
        var a = this; a.editing = !0;
        var b = a.obj.options.minSpeed; a.obj.options.minSpeed = 0.35 > b ? 0.35 : b;
        var d = this.label(); this.label("");
        var g = function () {
            a.label("<span>" + d + "</span>");
            a.editing = !1; a.obj.options.minSpeed = b; a.obj.animate()
            console.log(d);// Break Point ---
            console.log(a.children[0], a.children[1], a.parent);
        },
        f = c('<input class="edit-field" type="text" />').val(d);
        f.keyup(function (e) {
            e = e.which; if (e === 27) g();
            else if (e === 13) {
                console.log("inside 13");// breakthrough point
                e = f.val(), a.label("<span>" + e + "</span>"), a.obj.trigger("onchange", a, a.obj.serialize()), a.editing = !1, a.obj.options.minSpeed = b, a.obj.animate();
                var strparent = a.parent.label();
                a.parent.el.css("background","#FF8000");
                //a.parent.el.css("color","red");
                //a.el.css("color","black");
                var url = new String();
                url = f.val();
                var urlArray = url.split("-");
                var name;
                var itemurl;
                if (urlArray.length > 1) {
                    name =f.val();
                    itemurl = urlArray[1];
                    a.el.css("background", "#F5A9A9");
                    //a.el.css("color", "white");
                }
                else {
                    itemurl = null;
                    name = f.val();
                    a.el.css("background","#FFBF00");
                }
                
                constructItemMirror2(strparent,name,itemurl);
            }
            return !0
        });
        /*f.mouseup(function (e) {
            console.log("inside 13");// breakthrough point
            e = f.val(), a.label("<span>" + e + "</span>"), a.obj.trigger("onchange", a, a.obj.serialize()), a.editing = !1, a.obj.options.minSpeed = b, a.obj.animate();
            var strparent = a.parent.label();
            a.parent.el.css("background", "yellow");
            a.parent.el.css("color", "red");
            a.el.css("color", "black");
            var url = new String();
            url = f.val();
            var urlArray = url.split("-");
            var name;
            var itemurl;
            if (urlArray.length > 1) {
                name = f.val();
                itemurl = urlArray[1];
                a.el.css("background", "blue");
                a.el.css("color", "white");
            }
            else {
                itemurl = null;
                name = f.val();
                a.el.css("background", "white");
            }

            constructItemMirror2(strparent, name, itemurl);
            return!0
        });*/
        f.appendTo(a.el).focus().select();
		c('<button title="Click to add new node" class="edit-button">+</button>').click(function ()
        {
            var r = confirm("Do you wish to add a subtopic?");
            if (r) {
                a.el.addClass("active");
                g();
                a.obj.addNode(a).edit();
                return !1
            }
        }).appendTo(a.el);
        c('<button title="Click to delete this node" class="edit-button">x</button>').click(function () {
            var r = confirm("Do you wish to delete the topic? It will also delete subtopics under this topic.");
            if (r) {
                g(); a.removeNode(); a.obj.animate(); return !1
            }
        }).appendTo(a.el); return !1
    };
    h.prototype.removeNode = function () {
        for (this.obj.trigger("onremove", this) ; this.children.length > 0;)
            this.children[0].removeNode();
        this.parent && this.parent.children.splice(this.parent.children.indexOf(this), 1);
        this.obj.nodes.splice(this.obj.nodes.indexOf(this), 1);
        var a = this.obj.lines;
        this.obj.lines = [];
        for (var b = 0; b < a.length; b++) a[b].start === this || a[b].end === this || this.obj.lines.push(a[b]);
        c(this.el).remove();
        this.obj.trigger("onchange", this, this.obj.serialize());
        var strDelete = this.label();
        var strDeleteParent = this.parent.label();
        deleteNode(strDeleteParent, strDelete);
        this.obj.animate()
    };
    h.prototype.findEquilibrium = function () {
        for (var a = !this.parent ? !0 : this.display(), b = 0; b < this.children.length; b++)
            if (this.children[b].visible || this.el.hasClass("active")) a = this.children[b].findEquilibrium() && a;
          return a
    };
    h.prototype.hide = function () {
        this.obj.trigger("onhide", this);
        this.el.removeClass("active");
        this.el.hide();
        this.hasPosition = this.visible = !1
    };
    h.prototype.show = function () {
        this.el.show();
        this.visible = !0;
        this.obj.trigger("onshow", this)
    };
    h.prototype.setPosition = function (a, b) {
        this.x = a; this.y = b;
        this.el.css("left", a + "px");
        this.el.css("top", b + "px");
        this.hasPosition = !0
    };
    h.prototype.display = function () {
        this.visible ? this.parent.el.hasClass("active") || this.hide() : (this.parent.parent === null || this.parent.el.hasClass("active")) && this.show();
        if (!this.visible) return !0;
        if (!this.hasPosition) {
            if (this.parent.parent !== null)
                var a = parseInt(this.parent.el.css("left")), b = parseInt(this.parent.el.css("top"));
            else a = this.obj.width / 2, b = this.obj.height / 2;
            this.setPosition(a, b)
        } var d = Math.PI * 2 / this.children.length, g = this;
        c.each(this.children, function (a) { if (!this.visible) { var b = a * d, a = 100 * Math.cos(b) + g.x, b = 100 * Math.sin(b) + g.y; this.setPosition(a, b) } });
        return this.updatePosition()
    };
    h.prototype.updatePosition = function () {
        if (c(this.el).hasClass("ui-draggable-dragging"))
            return this.x = parseInt(this.el.css("left")) + c(this.el).width() / 2 - this.obj.offset.left,
                this.y = parseInt(this.el.css("top")) + c(this.el).height() / 2 - this.obj.offset.top,
                this.dy = this.dx = 0, !1;
        var a = this.getForceVector();
        this.dx += a.x * this.obj.options.acceleration;
        this.dy += a.y * this.obj.options.acceleration;
        this.dx *= this.obj.options.damping;
        this.dy *= this.obj.options.damping; if (Math.abs(this.dx) < this.obj.options.minSpeed)
            this.dx = 0; if (Math.abs(this.dy) < this.obj.options.minSpeed) this.dy = 0;
            if (Math.abs(this.dx) + Math.abs(this.dy) == 0)
                return !0;
            this.x += this.dx * this.obj.options.acceleration;
            this.y += this.dy * this.obj.options.acceleration;
            this.x = Math.min(this.obj.width, Math.max(1, this.x));
            this.y = Math.min(this.obj.height, Math.max(1, this.y));
            var a = this.obj.offset.left + this.x - c(this.el).width() / 2, b = this.obj.offset.top + this.y - c(this.el).height() / 2 - 10;
            this.el.css("left", a + "px"); this.el.css("top", b + "px");
            return !1
    };
    h.prototype.getForceVector = function () {
        for (var a = 0, b = 0, d = this.obj.nodes, g = this.obj.lines, f = 0; f < d.length; f++)
            if (d[f] !== this && (!this.obj.options.showSublines || d[f].hasPosition) && d[f].visible)
        {
            var e = d[f].x - this.x, c = d[f].y - this.y, h = e / Math.abs(e); Math.abs(c);
            var i = Math.sqrt(e * e + c * c), c = Math.atan(c / e); e === 0 && (c = Math.PI / 2, h = 0);
            e = this.obj.options.repulse * 500 / (i * i); Math.abs(i) < 500 && (a += -e * Math.cos(c) * h, b += -e * Math.sin(c) * h)
            }
        f = this.x + this.el.width(); e = this.obj.options.wallRepulse * 500 / (f * f); a += Math.min(2, e);
        f = this.obj.width - f;
        e = -(this.obj.options.wallRepulse * 500) / (f * f); a += Math.max(-2, e);
        e = this.obj.options.wallRepulse * 500 / (this.y * this.y); b += Math.min(2, e);
        f = this.obj.height - this.y;
        e = -(this.obj.options.wallRepulse * 500) / (f * f); b += Math.max(-2, e);
        for (f = 0; f < g.length; f++)
        {
            d = null;
            if (g[f].start === this)
                d = g[f].end;
            else if (g[f].end === this)
                d = g[f].start;
            else continue;
            d.visible &&
            (e = d.x - this.x, c = d.y - this.y, i = Math.sqrt(e * e + c * c), h = e / Math.abs(e), c = Math.atan(c / e), e == 0 && (c = Math.PI / 2, h = 0), e = this.obj.options.attract * i / 1E4, Math.abs(i) > 0 && (a += e * Math.cos(c) * h, b += e * Math.sin(c) * h))
        }
        Math.abs(a) > this.obj.options.maxForce && (a = this.obj.options.maxForce * (a / Math.abs(a))); Math.abs(b) > this.obj.options.maxForce && (b = this.obj.options.maxForce * (b / Math.abs(b)));
        return { x: a, y: b }
    };
    var i = function (a, b) {
        var d = this; this.el = c(a); this.el[0].buzzmap = this; this.el.addClass("buzzmap");
        this.nodes = []; this.lines = [];
        this.parseOptions(b);
        this.moveTimer = 0;
        this.stopMovement = this.moving = !1;
        this.fps = 0;
        window.setInterval(function () { var a = d.fps * 2; d.fps = 0; d.trigger("fps", a) }, 500); c(window).resize(function () { d.animate() });
        this.root = this.nodes[0] = new h(this, null, "<span>Buzzmap</span>")
    };
    j.mixin(i); i.prototype.createCanvas = function () {
        this.height = this.el.height();
        this.width = this.el.width();
        this.canvas ? this.canvas.setSize(this.width, this.height) : this.canvas = Raphael(this.el[0], this.width, this.height);
        this.offset = this.el.css("position") == "relative" ? { top: 0, left: 0 } : this.el.offset()
    };
    i.prototype.addNode = function (a, b) {
        var c = this.nodes[this.nodes.length] = new h(this, a, b);
        this.animate();
        return c
    };
    i.prototype.serialize = function () {
        return this.root.serialize()
    };
    i.prototype.animate = function () {
        var a = this;
        if (a.options.animationTimeout != 0) clearTimeout(a.moveTimer), a.moveTimer = setTimeout(function () { a.stopMovement = !0 }, a.options.animationTimeout * 1E3);
        if (!a.moving) a.createCanvas(), a.moving = !0, a.stopMovement = !1, a.animateLoop()
    };
    i.prototype.animateLoop = function () {
        var a = this; this.canvas.clear();
        for (var b = 0; b < this.lines.length; b++) this.lines[b].updatePosition();
        this.root.findEquilibrium() || this.stopMovement ? this.moving = !1 : window.setTimeout(function () { a.fps++; a.animateLoop() }, 1E3 / a.options.maxFps)
    };
    i.prototype.parseOptions = function (a) {
        this.options = c.extend({
            structure: null, editable: !1,
            onchange: function () { },
            ondrag: function () { },
            onshow: function () { },
            onhide: function () { },
            onremove: function () { },
            fps: function () { },
            attract: 5, repulse: 5, wallRepulse: 0.5, maxForce: 0.25, damping: 0.9, acceleration: 5, lineWidth: "5px", lineColor: "#FFF", lineOpacity: 0.3, minSpeed: 0.2, animationTimeout: 5
        }, a);
        this.bind("onchange", this.options.onchange);
        this.bind("ondrag", this.options.ondrag);
        this.bind("onshow", this.options.onshow);
        this.bind("onhide", this.options.onhide);
        this.bind("onremove", this.options.onremove);
        this.bind("fps", this.options.fps)
    };
    c.fn.buzzmap = function (a) {
        var b = new i(this[0], a);
        if (!b.options.structure) return b;
        var a = function ()
        {
            c('<style type="text/css"></style>').text(".ui-draggable{position:absolute !important;}").appendTo("head"); b.animate();
            return b
        },
        d = c(b.options.structure).filter("ul");
        if (d.length > 0)
        {
            var g = function () {
                var a = c(this).parents("li").get(0), a = !a ? b.root : a.buzznode;
                this.buzznode = b.addNode(a, c("div:eq(0)", this).html());
                c(this).hide(); c(">ul>li", this).each(g)
            };
            c(">li", d).each(g); return a()
        }
        if (typeof b.options.structure !== "string")
        throw Error("Buzzmap: Couldn't interpret the passed structure");
        try {
            var f = JSON.parse(b.options.structure), e = function (a, d)
            {
                c.each(d, function (c, d) {
                    if (d.label && d.children)
                    {
                        var f = b.addNode(a, d.label);

                        e(f, d.children)
                    }
                })
            };
            e(b.root, f.children)
        }
        catch (h) { throw Error("Buzzmap: Couldn't interpret the passed structure"); } return a()
    }

    function constructItemMirror2(itemName, name,itemurl) {

        console.log(name);
        console.log(itemurl);
         
        require(["ItemMirror"], function(ItemMirror){
			 "use strict";
        
        var
              dropboxClient,
              dropboxXooMLUtility,
              dropboxItemUtility,
              mirrorSyncUtility,
              URIToGroupingItem,
              itemMirrorOptions,
              createAssociationCase1Options,
              createAssociationCase2Options,
              createAssociationCase7Options,
              itemMirrors;



        dropboxClient = new Dropbox.Client({
            //key: "pDdjbuFEJpA=|5/z0giIAG3+tApfpyMbP3Wuyc0shm6DdOvk8q+Y5qA==",
        	//key: "YTKSGBUodHA=|Pm0x0m5s+2lDR4d8ekUb4jmeNE+cQDNpeLo2uT09LA==",
        	
        	key: "I5bzV3GCAYA=|aG1QByPTEYm0yGw7YhGQJXDRuClbj6fv5tRKWXfwJA==", // full dropbox
        	//key : "aaQWCQSVcxA=|DRJXtH9WH1bxz0sNVssBV5IfgPfYpQlVMLqcee9z1g==", //yan
        	sandbox: false
        });
        dropboxClient.authDriver(new Dropbox.Drivers.Redirect({
            rememberUser: true
        }));
        dropboxXooMLUtility = {
            utilityURI: "DropboxXooMLUtility",
            dropboxClient: dropboxClient
        };
        dropboxItemUtility = {
            utilityURI: "DropboxItemUtility",
            dropboxClient: dropboxClient
        };
        mirrorSyncUtility = {
            utilityURI: "MirrorSyncUtility"
        };
        URIToGroupingItem = "/";
        itemMirrorOptions = {
            1: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility
            },
            2: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility,
                syncUtility: mirrorSyncUtility,
                createIfDoesNotExist: false
            },
            3: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility,
                syncUtility: mirrorSyncUtility,
                createIfDoesNotExist: true
            }
        };
        createAssociationCase1Options = {
            displayText: name
        };
        createAssociationCase2Options = {
            "displayText": name,
            "itemURI": itemurl
        };
        createAssociationCase7Options = {
            "displayText": name,
            "itemName": name,
            "isGroupingItem": true
        };
        new ItemMirror(itemMirrorOptions[3], function (error, itemMirror) {
            if (error) { throw error; }
            var strName = new Array();
            var guid;

            if (itemName == "TravelPlan") {
                if (itemurl == null) {
                    itemMirror.createAssociation(createAssociationCase1Options, function (error, GUID) {
                        if (error) {
                            throw error;
                        }
                    });
                }
                else {
                    itemMirror.createAssociation(createAssociationCase2Options, function (error, GUID) {
                        if (error) {
                            throw error;
                        }
                    });
                }
            }

            else {
                itemMirror.listAssociations(function (error, strName) {
                    if (error) {
                        throw error;
                    }
                    for (var i = 0; i < strName.length; i++) {
                        itemMirror.getAssociationDisplayText(strName[i], function (error, displayText) {
                            if (error) {
                                throw error;
                            }
                            if (displayText == itemName) {
                            	
                                itemMirror.isAssociatedItemGrouping(strName[i], function (error, result) {
                                    if (error) { throw error; }
                                 if (!result) {
                                	 guid = strName[i];
                                    //itemMirrorOptions[3].groupingItemURI = itemName + "/"
                                        itemMirror.upgradeAssociation({"GUID": strName[i]}, function (error) {
                                            if (error) {
                                                throw error; // You might get a "404" error thrown here if "case1" already exists
                                                // that's because upgrades only work if a grouping item doesn't already exist!
                                            }
                                            
                                            //
                                            
                                            
                                            //
                                        });
                                }
                                });
                            }
                        });
                    }
                });
                itemMirror.createItemMirrorFromAssociatedGroupingItem(
                		guid, function (error, newItemMirror) {
		                if (error) { throw error; }
	    		        console.log("execution started to create child itemmirror");
	    		        if (itemurl == null)
	    		        	{
	    		        	if(newItemMirror==null)
	    		        		{
	    		        		console.log("newItemMirror is null");
	    		        		}
	    		        	else {
	    		        	newItemMirror.createAssociation(createAssociationCase1Options, function (error, GUID) {
                            if (error) {
                                throw error;
                            }
                        }); 
	    		        	}
	    		        	}
	    		        else
	    		        	{
	    		        	newItemMirror.createAssociation(createAssociationCase2Options, function (error, GUID) {
	                            if (error) {
	                                throw error;
	                            }
	    		        	});
	    		        	}
	    		        if(newItemMirror==null)
		        		{
		        		console.log("newItemMirror is null");
		        		}
		        });
                }
        });
        
        });
    }

    function deleteNode(itemName, strchild) {
    	
    	require(["ItemMirror"], function(ItemMirror){
			 "use strict";

        var
          dropboxClient,
          dropboxXooMLUtility,
          dropboxItemUtility,
          mirrorSyncUtility,
          URIToGroupingItem,
          itemMirrorOptions,
          createAssociationCase1Options,
          createAssociationCase2Options,
          createAssociationCase7Options,
          itemMirrors;



        dropboxClient = new Dropbox.Client({
            //key: "pDdjbuFEJpA=|5/z0giIAG3+tApfpyMbP3Wuyc0shm6DdOvk8q+Y5qA==",
        	//key: "YTKSGBUodHA=|Pm0x0m5s+2lDR4d8ekUb4jmeNE+cQDNpeLo2uT09LA==",
        	key : "I5bzV3GCAYA=|aG1QByPTEYm0yGw7YhGQJXDRuClbj6fv5tRKWXfwJA==", //full dropbox
        	//key : "aaQWCQSVcxA=|DRJXtH9WH1bxz0sNVssBV5IfgPfYpQlVMLqcee9z1g==", //yan
        	sandbox: false
        });
        dropboxClient.authDriver(new Dropbox.Drivers.Redirect({
            rememberUser: true
        }));
        dropboxXooMLUtility = {
            utilityURI: "DropboxXooMLUtility",
            dropboxClient: dropboxClient
        };
        dropboxItemUtility = {
            utilityURI: "DropboxItemUtility",
            dropboxClient: dropboxClient
        };
        mirrorSyncUtility = {
            utilityURI: "MirrorSyncUtility"
        };
        URIToGroupingItem = "/";
        itemMirrorOptions = {
            1: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility
            },
            2: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility,
                syncUtility: mirrorSyncUtility,
                createIfDoesNotExist: false
            },
            3: {
                groupingItemURI: URIToGroupingItem,
                xooMLUtility: dropboxXooMLUtility,
                itemUtility: dropboxItemUtility,
                syncUtility: mirrorSyncUtility,
                createIfDoesNotExist: true
            }
        };
        createAssociationCase1Options = {
            displayText: strchild
        };
        createAssociationCase2Options = {
            "displayText": strchild,
            "itemURI": "http://ischool.uw.edu/about"
        };
        createAssociationCase7Options = {
            "displayText": strchild,
            "itemName": strchild,
            "isGroupingItem": true
        };
        new ItemMirror(itemMirrorOptions[3], function (error, itemMirror) {
            if (error) { throw error; }
            var strName = new Array();

            if (itemName == "TravelPlan") {
                itemMirror.listAssociations(function (error, strName) {
                    if (error) {
                        throw error;
                    }
                    for (var i = 0; i < strName.length; i++) {
                        itemMirror.getAssociationDisplayText(strName[i], function (error, displayText) {
                            if (error) {
                                throw error;
                            }
                            if (displayText == strchild) {
                                itemMirror.deleteAssociation(strName[i], function (error) {
                                    if (error) {
                                        throw error; // You might get a "404" error thrown here if "case1" already exists
                                        // that's because upgrades only work if a grouping item doesn't already exist!
                                    }
                                });
                            }
                        });
                    }
                });

            }

            else
                {
                itemMirrorOptions[3].groupingItemURI = itemName + "/"
                new ItemMirror(itemMirrorOptions[3], function (error, itemMirror) {
                    if (error) { throw error; }
                    itemMirror.listAssociations(function (error, strName) {
                        if (error) {
                            throw error;
                        }
                        for (var i = 0; i < strName.length; i++) {
                            itemMirror.getAssociationDisplayText(strName[i], function (error, displayText) {
                                if (error) {
                                    throw error;
                                }
                                if (displayText == strchild) {
                                    itemMirror.deleteAssociation(strName[i], function (error) {
                                        if (error) {
                                            throw error; // You might get a "404" error thrown here if "case1" already exists
                                            // that's because upgrades only work if a grouping item doesn't already exist!
                                        }
                                    });
                                }
                            });
                        }
                    });
                });

            }
        });
     });
    }

})(jQuery);